# 解题相关

要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。
在 js 中使用 splice 每次删除一个元素后面的元素都会发生移动，会导致时间复杂度变为 n \* n

# Rust 迭代速查表

## 1) 三种“迭代入口”概念

- `iter()`：迭代 **不可变引用** `&T`，**不消耗**容器。
- `iter_mut()`：迭代 **可变引用** `&mut T`，**不消耗**容器。
- `into_iter()`：**按值**迭代 `T`（取得所有权），**消耗**容器（取决于你手里的到底是 `Vec<T>` 还是引用，见下）。

---

## 2) 不同绑定类型下 `.into_iter()` 的行为

| 变量类型                  | `.into_iter()` 产物  | 是否“消耗”容器 | 迭代到的元素类型  | 能否修改元素      | 能否对 `Vec` 本身做 `push/pop/索引写入`            |
| ------------------------- | -------------------- | -------------: | ----------------- | ----------------- | -------------------------------------------------- |
| `Vec<T>`（按值）          | 真正的 into-iterator |          ✅ 是 | `T`（拥有所有权） | N/A（拿走元素了） | ❌（容器已被 move）                                |
| `&Vec<T>`（不可变借用）   | 等价于 `iter()`      |          ❌ 否 | `&T`              | ❌                | ❌（只有 `&Vec`）                                  |
| `&mut Vec<T>`（可变借用） | 等价于 `iter_mut()`  |          ❌ 否 | `&mut T`          | ✅（改当前元素）  | ❌（有一个贯穿迭代期的 `&mut Vec` 借用，无法再借） |

> 记忆口诀：
>
> - **按值 `Vec<T>`** 调 `into_iter()` → 真“into”，消耗容器、拿到 `T`。
> - **引用 `&Vec` / `&mut Vec`** 调 `into_iter()` → 其实就是 `iter()` / `iter_mut()` 的语法糖。

---

## 3) `iter()` / `iter_mut()` / `into_iter()` 的典型写法

```rust
// 只读遍历（不改、也不消耗）
for &x in nums.iter() { /* 用 x */ }          // 或：for x in &nums {}

// 可改元素（不消耗容器）
for x in nums.iter_mut() { *x += 1; }         // 或：for x in &mut nums {}

// 真正消耗容器（拿到所有权）
for x in nums.into_iter() { /* x: T */ }      // 之后不能再用 nums
```

---

## 4) 与借用规则相关的坑（LeetCode 27 常见）

- 用 `iter()` 遍历时，它给 `nums` 建立**整体不可变借用**；
  如果你同时写 `nums[k] = ...`（需要 `&mut Vec<_>`）→ **冲突**。
- 用 `&mut Vec<_>` + `into_iter()`（实际是 `iter_mut()`）：
  可以 `*x = ...` 改“当前元素”，但**不能**再对 `Vec` 本身做 `push/pop/索引写入到别处`（仍是借用冲突）。
- 想一边读一边写回**同一个** `Vec` 的不同位置，**推荐索引遍历**：

  ```rust
  let mut k = 0usize;
  for i in 0..nums.len() {
      let x = nums[i];      // 先读出（i32 是 Copy）
      if x != val {
          nums[k] = x;      // 再写回
          k += 1;
      }
  }
  ```

---

## 5) 解构模式的小细节

- `iter()` 产物是 `&T`：写 `for &x in nums.iter()`，或 `for (i, &x) in nums.iter().enumerate()`。
- `iter_mut()` / `&mut Vec` 的 `into_iter()` 产物是 `&mut T`：写 `for x in nums.iter_mut()`，需要用 `*x`。
- `Vec<T>` 的 `into_iter()` 产物是 `T`：写 `for x in nums.into_iter()`，无需解引用。

---

## 6) 何时用 `enumerate()`

- 需要 **(索引, 元素)** 时配合：

  - `iter().enumerate()` → `(usize, &T)`，常写 `(i, &x)`。
  - `iter_mut().enumerate()` → `(usize, &mut T)`，常写 `(i, x)` 然后 `*x`。
  - `into_iter().enumerate()`（按值消耗）→ `(usize, T)`。

- 如果你在循环里还要**写回别处索引**的位置，优先考虑**索引遍历**（避免借用冲突）。

---

## 7) 小结（一句话版）

- **只读**：`iter()`；
- **就地改元素**：`iter_mut()` 或 `&mut Vec` 的 `into_iter()`；
- **拿走所有权/消耗**：`Vec<T>` 的 `into_iter()`；
- **需要索引**：加 `enumerate()`；
- **读写同一 `Vec` 的不同位置**：用**索引遍历**最稳（避免借用冲突）。
